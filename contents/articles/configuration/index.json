{
  "title": "Docker In Docker (DIND) 설정하기",
  "description": "Docker in Docker를 설정하는 이유 첫 번째로 보안의 위험이 있다. 특히나, Jenkins등의 CI를 사용하는 환경에서 Jenkins가 Docker를 실행할 때, Jenkins나 Docker가 해킹당하면 서버 전체의 권한이 뚫리는거랑 마찬가지이다. 그러므로 ...",
  "date": "2019-05-30T16:33:52.000Z",
  "tags": [],
  "slug": "configuration",
  "url": "/articles/configuration",
  "contentType": "articles",
  "author": "Vallista",
  "readingTime": 5,
  "draft": true,
  "content": "Docker in Docker를 설정하는 이유 첫 번째로 보안의 위험이 있다.\n\n특히나, Jenkins등의 CI를 사용하는 환경에서 Jenkins가 Docker를 실행할 때, Jenkins나 Docker가 해킹당하면 서버 전체의 권한이 뚫리는거랑 마찬가지이다. 그러므로 소스코드 유출 및 사용자에게 Serve 할 때 문제가 일어나게 된다. 그러므로 Docker로 한번 더 감싸서 Docker Wrapper에 권한을 하나 더 만든다. 그 다음 Docker Wrapper의 가상 환경에 jenkins와 docker 이미지를 만들고 가상 환경의 서버에서 jenkins와 docker 인스턴스를 실행시킨다. 이렇게 되면 jenkins, docker서버가 해킹당하더라도 docker wrapper instance만 해킹이 되기 때문에 안전하다.\n\n두 번째는 백업이다.\n\njenkins와 docker가 단독으로 instance로써 작동할 때 서버가 꺼지거나 하면 백업이 쉽지 않다. 하지만 docker wrapper로 감싸게 되면 백업에 용이하다.\n\n## Docker In Docker(dind) 설정\n\n1. [jpetazzo/dind](https://github.com/jpetazzo/dind)\n2. [Jenkins를 이용한 Docker 빌드](http://seapy.com/2083)\n\n위의 자료를 참고했다. 프로젝트에 아래의 파일들을 적용한다.\n\n- Dockerfile\n\n```bash\nFROM jenkins:2.60.3\nMAINTAINER jerome.petazzoni@docker.com\n\nUSER root\n\n# Let's start with some basic stuff.\nRUN apt-get update -qq && apt-get install -qqy \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    lxc \\\n    iptables \\\n    ca-certificates\n\n# Install Docker from Docker Inc. repositories.\nRUN curl -sSL https://get.docker.com/ | sh\n\n# Install the magic wrapper.\nADD ./wrapdocker /usr/local/bin/wrapdocker\nRUN chmod +x /usr/local/bin/wrapdocker\n\n# Define additional metadata for our image.\nVOLUME /var/lib/docker\n\nENV JAVA_ARGS -Xms512m -Xmx1024m\n\nCMD [\"/usr/local/bin/wrapdocker\"]\n\nADD jenkins_dind.sh /usr/local/bin/jenkins_dind.sh\nRUN chmod +x /usr/local/bin/jenkins_dind.sh\n\nCMD [\"/usr/local/bin/jenkins_dind.sh\"]\n```\n\n- wrapdocker\n\n```bash\n#!/bin/bash\n\n# Ensure that all nodes in /dev/mapper correspond to mapped devices currently loaded by the device-mapper kernel driver\ndmsetup mknodes\n\n# First, make sure that cgroups are mounted correctly.\nCGROUP=/sys/fs/cgroup\n: {LOG:=stdio}\n\n[ -d $CGROUP ] ||\n        mkdir $CGROUP\n\nmountpoint -q $CGROUP ||\n        mount -n -t tmpfs -o uid=0,gid=0,mode=0755 cgroup $CGROUP || {\n                echo \"Could not make a tmpfs mount. Did you use --privileged?\"\n                exit 1\n        }\n\nif [ -d /sys/kernel/security ] && ! mountpoint -q /sys/kernel/security\nthen\n    mount -t securityfs none /sys/kernel/security || {\n        echo \"Could not mount /sys/kernel/security.\"\n        echo \"AppArmor detection and --privileged mode might break.\"\n    }\nfi\n\n# Mount the cgroup hierarchies exactly as they are in the parent system.\nfor SUBSYS in $(cut -d: -f2 /proc/1/cgroup)\ndo\n        [ -d $CGROUP/$SUBSYS ] || mkdir $CGROUP/$SUBSYS\n        mountpoint -q $CGROUP/$SUBSYS ||\n                mount -n -t cgroup -o $SUBSYS cgroup $CGROUP/$SUBSYS\n\n        # The two following sections address a bug which manifests itself\n        # by a cryptic \"lxc-start: no ns_cgroup option specified\" when\n        # trying to start containers withina container.\n        # The bug seems to appear when the cgroup hierarchies are not\n        # mounted on the exact same directories in the host, and in the\n        # container.\n\n        # Named, control-less cgroups are mounted with \"-o name=foo\"\n        # (and appear as such under /proc/<pid>/cgroup) but are usually\n        # mounted on a directory named \"foo\" (without the \"name=\" prefix).\n        # Systemd and OpenRC (and possibly others) both create such a\n        # cgroup. To avoid the aforementioned bug, we symlink \"foo\" to\n        # \"name=foo\". This shouldn't have any adverse effect.\n        echo $SUBSYS | grep -q ^name= && {\n                NAME=$(echo $SUBSYS | sed s/^name=//)\n                ln -s $SUBSYS $CGROUP/$NAME\n        }\n\n        # Likewise, on at least one system, it has been reported that\n        # systemd would mount the CPU and CPU accounting controllers\n        # (respectively \"cpu\" and \"cpuacct\") with \"-o cpuacct,cpu\"\n        # but on a directory called \"cpu,cpuacct\" (note the inversion\n        # in the order of the groups). This tries to work around it.\n        [ $SUBSYS = cpuacct,cpu ] && ln -s $SUBSYS $CGROUP/cpu,cpuacct\ndone\n\n# Note: as I write those lines, the LXC userland tools cannot setup\n# a \"sub-container\" properly if the \"devices\" cgroup is not in its\n# own hierarchy. Let's detect this and issue a warning.\ngrep -q :devices: /proc/1/cgroup ||\n        echo \"WARNING: the 'devices' cgroup should be in its own hierarchy.\"\ngrep -qw devices /proc/1/cgroup ||\n        echo \"WARNING: it looks like the 'devices' cgroup is not mounted.\"\n\n# Now, close extraneous file descriptors.\npushd /proc/self/fd >/dev/null\nfor FD in *\ndo\n        case \"$FD\" in\n        # Keep stdin/stdout/stderr\n        [012])\n                ;;\n        # Nuke everything else\n        *)\n                eval exec \"$FD>&-\"\n                ;;\n        esac\ndone\npopd >/dev/null\n\n# If a pidfile is still around (for example after a container restart),\n# delete it so that docker can start.\nrm -rf /var/run/docker.pid\n\n# If we were given a PORT environment variable, start as a simple daemon;\n# otherwise, spawn a shell as well\nif [ \"$PORT\" ]\nthen\n        exec dockerd -H 0.0.0.0:$PORT -H unix:///var/run/docker.sock \\\n                $DOCKER_DAEMON_ARGS\nelse\n        if [ \"$LOG\" == \"file\" ]\n        then\n                dockerd $DOCKER_DAEMON_ARGS &>/var/log/docker.log &\n        else\n                dockerd $DOCKER_DAEMON_ARGS &\n        fi\n        (( timeout = 60 + SECONDS ))\n        until docker info >/dev/null 2>&1\n        do\n                if (( SECONDS >= timeout )); then\n                        echo 'Timed out trying to connect to internal docker host.' >&2\n                        break\n                fi\n                sleep 1\n        done\n        [[ $1 ]] && exec \"$@\"\n        exec bash --login\nfi\n```\n\n- jenkins_dind.sh\n\n```bash\n#!/bin/bash\n\nCGROUP=/sys/fs/cgroup\n\n[ -d $CGROUP ] ||\n  mkdir $CGROUP\n\nmountpoint -q $CGROUP ||\n  mount -n -t tmpfs -o uid=0,gid=0,mode=0755 cgroup $CGROUP || {\n    echo \"Could not make a tmpfs mount. Did you use -privileged?\"\n    exit 1\n  }\n\n# Mount the cgroup hierarchies exactly as they are in the parent system.\nfor SUBSYS in $(cut -d: -f2 /proc/1/cgroup)\ndo\n  [ -d $CGROUP/$SUBSYS ] || mkdir $CGROUP/$SUBSYS\n  mountpoint -q $CGROUP/$SUBSYS ||\n    mount -n -t cgroup -o $SUBSYS cgroup $CGROUP/$SUBSYS\ndone\n\n# Now, close extraneous file descriptors.\npushd /proc/self/fd\nfor FD in *\ndo\n  case \"$FD\" in\n  # Keep stdin/stdout/stderr\n  [012])\n    ;;\n  # Nuke everything else\n  *)\n    eval exec \"$FD>&-\"\n    ;;\n  esac\ndone\npopd\n\ndocker -d &\nexec /usr/bin/java -jar /usr/share/jenkins/jenkins.war\n```\n\n## 참고\n\n1. [Node.js 웹 앱의 도커라이징 | Node.js](https://nodejs.org/ko/docs/guides/nodejs-docker-webapp/)\n2. [초보를 위한 도커 안내서 - 도커란 무엇인가?](https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html)",
  "frontmatter": {
    "title": "Docker In Docker (DIND) 설정하기",
    "tags": [],
    "date": "2019-05-30T16:33:52.000Z",
    "draft": true,
    "info": false,
    "slug": "configuration"
  }
}